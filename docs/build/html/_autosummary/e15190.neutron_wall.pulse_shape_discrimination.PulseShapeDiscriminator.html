
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator &#8212; Data Analysis for E15190-E14030  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinxdoc.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Data Analysis for E15190-E14030  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="e15190-neutron-wall-pulse-shape-discrimination-pulseshapediscriminator">
<h1>e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator<a class="headerlink" href="#e15190-neutron-wall-pulse-shape-discrimination-pulseshapediscriminator" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">e15190.neutron_wall.pulse_shape_discrimination.</span></span><span class="sig-name descname"><span class="pre">PulseShapeDiscriminator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Functions</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.__init__" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(AB[, max_workers])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.cache_run" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.cache_run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_run</span></code></a>(run[, tree_name])</p></td>
<td><p>Read in the data from ROOT file and save relevant branches to an HDF5 file.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_ranges</span></code>(low, upp, width[, step])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">denormalize_features</span></code>([df])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">discrimination_using_pca</span></code>([normalize_psd_values])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extrapolate_linearly</span></code>(func, boundary)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.figure_of_merit" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.figure_of_merit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">figure_of_merit</span></code></a>(arr, **find_peaks_kwargs)</p></td>
<td><p>Calculate the figure-of-merit that quantifies the two-peak separation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.find_topN_peaks" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.find_topN_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_topN_peaks</span></code></a>(arr[, n_peaks, bins, ...])</p></td>
<td><p>Find the first-N highest peaks from the distribution of arr.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_two_2dpeaks</span></code>(x, y, **find_peaks_kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.fit" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>()</p></td>
<td><p>To calculate the pulse shape discrimination parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_fast_total</span></code>(side[, position_range, ax, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_position_correction</span></code>([light_GM_cut])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_position</span></code>(df_time, pos_calib_params)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_features</span></code>([df])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_psd_values</span></code>(psd_column, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.position_correction" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.position_correction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_correction</span></code></a>()</p></td>
<td><p>A function that maps (vpsd_L, vpsd_R, pos) to (ppsd, ppsd_perp)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocessing</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">randomize_integer_features</span></code>([seed])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.read" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read</span></code></a>(run, bar[, from_cache, verbose])</p></td>
<td><p>Read in the data needed to do pulse shape discrimintion.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_run_from_root_file</span></code>(run[, tree_name, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_distorted_fast_total</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_vetowall_coincidences</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.save_parameters" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.save_parameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_parameters</span></code></a>([path])</p></td>
<td><p>Save pulse shape discrimination parameters as a JSON file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.save_to_gallery" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.save_to_gallery"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_to_gallery</span></code></a>([path, cut, show_plot, save])</p></td>
<td><p>Save a diagnostic plot to the gallery as a PNG file.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.value_assign" title="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.value_assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">value_assign</span></code></a>(side)</p></td>
<td><p>Value-assign a PSD value to each entry.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Properties</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adc_range</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">database_dir</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">light_GM_range</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pos_range</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">root_files_dir</span></code></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">AB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.cache_run">
<span class="sig-name descname"><span class="pre">cache_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.cache_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in the data from ROOT file and save relevant branches to an HDF5 file.</p>
<p>The data will be categorized according to bar number, because future
retrieval by this class will most likely analyze only one bar at a time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in the data needed to do pulse shape discrimintion.</p>
<p>The data will be read from the HDF5 file if it exists, otherwise they will be read in from the ROOT file (generated by Daniele’s framework).</p>
<dl class="simple">
<dt>Parameters</dt><dd><dl class="simple">
<dt>run<span class="classifier">int or list of ints</span></dt><dd><p>The run number(s) to read in. Most of the time, this will be a
list of at least five runs. Otherwise, the algorithm will have a
hard time find the pulse shape discrimintion parameters due to
low statistics.</p>
</dd>
<dt>bar<span class="classifier">int</span></dt><dd><p>The bar number to read in.</p>
</dd>
<dt>from_cache<span class="classifier">bool, default True</span></dt><dd><p>Whether to read in the data from the HDF5 cache. If False, the
data will be read in from the ROOT file. A new cache will be
created, overwriting any existing cache.</p>
</dd>
<dt>verbose<span class="classifier">bool, default False</span></dt><dd><p>Whether to print out the progress of the read in.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.find_topN_peaks">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">find_topN_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist_log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_half_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_range_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_gaus_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_kde</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kde_bandwidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.find_topN_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first-N highest peaks from the distribution of arr.</p>
<p>The algorithm is of recursive nature. It will always find only one peak -
the highest peak - at a time, then it subtracts the peak out from the
current distribution and proceeds to find the next highest peak. In each
recursion, the algorithm simply looks for the highest count of the
distribution (in histogram), meaning that it does not check whether the peak
is of any statistical significance. While users can specify as many
<cite>n_peaks</cite> as they want, the result only makes sense if <cite>arr</cite> does actually
contain that many peaks.</p>
<p>The algorithm uses a simple local Gaussian fit to each peak in order to
improve the precision of the peak locations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – <p>1D array
The array to find the peaks in its distribution. Normalization of
<cite>arr</cite> is done to set the mean to 0 and the standard deviation to 1,
so that the algorithm and hyperparameters are more robust to various
ranges of <cite>arr</cite>. Nonetheless, any results will be de-normalized
before being returned, i.e. they will be in the original scale or
unit.</p>
<p>All other arguments that use the same units as <cite>arr</cite> will always be
specified in the original unit. The normalization is always done
internally, so that users do not have to worry about it.</p>
</p></li>
<li><p><strong>n_peaks</strong> – int, default 2
The number of peaks to find.</p></li>
<li><p><strong>bins</strong> – int, default 150
The number of bins to use in the histogram that approximates the
distribution of <cite>arr</cite>.</p></li>
<li><p><strong>hrange</strong> – 2-tuple, default None
The range of the histogram in the unit of <cite>arr</cite>. If None, the range
is set to <cite>[-3, 3]</cite> in the normalized unit.</p></li>
<li><p><strong>hist_log</strong> – bool, default False
If True, the counts of the histogram will be log-transformed,
i.e. <cite>h = log(h + 1)</cite>, where <cite>log</cite> is the natural logarithm</p></li>
<li><p><strong>kernel_width</strong> – float, default 0.05
The width of the kernel used to smooth the histogram.</p></li>
<li><p><strong>kernel_half_range</strong> – float, default 2.0
The half-range of the kernel.</p></li>
<li><p><strong>fit_range_width</strong> – float, default None
The width, in the unit of <cite>arr</cite>, specifies regions around the
estimated peak positions that will be used to fit the Gaussian
curves. If None, the width is set to <cite>1.0</cite> in the normalized unit.</p></li>
<li><p><strong>return_gaus_fit</strong> – bool, default False
If True, the Gaussian fit to each peak is also returned.</p></li>
<li><p><strong>use_kde</strong> – bool, default False
If True, KDE is used to find the peak location after the
Gaussian fit.</p></li>
<li><p><strong>kde_bandwidth</strong> – float, default None
The bandwidth of the KDE in the unit of <cite>arr</cite>. If None, the
bandwidth is set to <cite>0.05</cite> in the normalized unit.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If <cite>return_gaus_fit</cite> is False, returns a 1D array of the peak positions
<cite>xpeaks</cite>, sorted from left to right; if <cite>return_gaus_fit</cite> is True,
returns a tuple <cite>(xpeaks, gpars)</cite>, where <cite>gpars</cite> contain the Gaussian
parameters for each peak.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.value_assign">
<span class="sig-name descname"><span class="pre">value_assign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">side</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.value_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Value-assign a PSD value to each entry.</p>
<p>Assigns gamma to 0 and neutron to 1. Values in between, e.g. 0.5, would
mean that the algorithm has a hard time confidently distinguishing
between gamma and neutron. However, values that are far from the
assigned values, e.g. 10.0 or -10.0, are likely to be noise too. So when
trying to select a particle, it is better to specify a range of assigned
values, VPSDs, e.g. [-1, 0.5] for gamma and [0.5, 2] for neutron.</p>
<p>Of course, this function is only assigning the PSD value based on
information from one side of the NW bar, which does not give very good
neutron-gamma separation. Also, hit position information is not used at
all. Eventually, the method <cite>PulseShapeDiscriminator.fit()</cite> would
provide a better PSD parameter that is built on top of this one-sided
VPSD parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>side</strong> – ‘L’ or ‘R’
The side of the NW bar to do the value-assignment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.position_correction">
<span class="sig-name descname"><span class="pre">position_correction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.position_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that maps (vpsd_L, vpsd_R, pos) to (ppsd, ppsd_perp)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>To calculate the pulse shape discrimination parameters.</p>
<p>This is a wrapper for multiple functions. If you run into any bugs and
need to debug the program, it is recommended to run the individual
functions one by one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.figure_of_merit">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">figure_of_merit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">find_peaks_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.figure_of_merit" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the figure-of-merit that quantifies the two-peak separation</p>
<p>The formula is F.O.M. = <a href="#id1"><span class="problematic" id="id2">|x0 - x1|</span></a> / (FWHM0 + FWHM1), which is standard
adopted in many literature on the subject of pulse shape discrimination.
One slight modification here is that, instead of using the actual FWHM,
we estimate it by first fitting a Gaussian around the peak, then take
FWHM to be ~2.3548 times sigma, the standard deviation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.save_parameters">
<span class="sig-name descname"><span class="pre">save_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.save_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Save pulse shape discrimination parameters as a JSON file.</p>
<p>By default, this function saves the parameters to the database as a JSON
file. An example path would be:
<cite>$PROJECT_DIR/database/calib_params/run-4082-4123-ha88b0/NWB-bar01.json</cite></p>
<dl class="simple">
<dt>Parameters</dt><dd><dl class="simple">
<dt>path<span class="classifier">str or pathlib.Path, default None</span></dt><dd><p>The path to save the parameters. If None, the parameters will be
saved to the default database.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.save_to_gallery">
<span class="sig-name descname"><span class="pre">save_to_gallery</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'light_GM</span> <span class="pre">&gt;</span> <span class="pre">3'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator.save_to_gallery" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a diagnostic plot to the gallery as a PNG file.</p>
<dl class="simple">
<dt>Parameters</dt><dd><dl class="simple">
<dt>path<span class="classifier">str or pathlib.Path, default None</span></dt><dd><p>The path to save the plot. If None, the plot is saved to the
default database.</p>
</dd>
<dt>cut<span class="classifier">str, default ‘light_GM &gt; 3’</span></dt><dd><p>The cut to apply to the data when plotting. All panels in the
figure will apply this cut, and potentially other cuts, joined
by logical AND, except for the panel that draws the PPSD as a
function of light GM.</p>
</dd>
<dt>show_plot<span class="classifier">bool, default False</span></dt><dd><p>If True, the plot will be shown in run time, i.e. the command
<cite>plt.show()</cite> will be called.</p>
</dd>
<dt>save<span class="classifier">bool, default True</span></dt><dd><p>If <cite>True</cite>, the plot will be saved to the database. <cite>False</cite>
option is useful when users are using this function to inspect
the plot without saving.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Data Analysis for E15190-E14030  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">e15190.neutron_wall.pulse_shape_discrimination.PulseShapeDiscriminator</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018-2021, MSU/FRIB HiRA group.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>