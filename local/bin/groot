#!/usr/bin/env python
import argparse
import functools
import pathlib
import subprocess
import sys

# arguments parsing
parser = argparse.ArgumentParser()
parser.add_argument('main_script')
parser.add_argument(
    '-o', '--output',
    help='specify the path to output executable',
    default='',
)
parser.add_argument(
    '-c', '--no-linker',
    help='do not run linker, i.e. output object file',
    action='store_true',
)
parser.add_argument(
    '-s', '--standalone',
    help='do not include any local object files and compile only this one current script',
    action='store_true',
)
parser.add_argument(
    '-v', '--verbose',
    help='show g++ compilation command',
    action='store_true',
)
args = parser.parse_args()

# identify paths and filenames
main_path = pathlib.Path(args.main_script)
if args.output == '':
    exec_path = pathlib.Path(pathlib.Path.cwd(), main_path.stem + '.exe') # output at current directory
else:
    exec_path = pathlib.Path(args.output).resolve()
repo_path = pathlib.Path(sys.prefix).parent.resolve()
header_dir = pathlib.Path(repo_path, 'local', 'include').resolve()
src_dir = pathlib.Path(repo_path, 'local', 'src').resolve()

# prepare compiler's options
subprocess.run = functools.partial(subprocess.run, shell=True, capture_output=True, text=True)
options = []

# CERN ROOT's includes and libraries
root_cflags = subprocess.run('root-config --cflags')
if root_cflags.stderr:
    sys.stderr.write(root_cflags.stderr)
    exit()

root_libs = subprocess.run('root-config --libs')
if root_libs.stderr:
    sys.stderr.write(root_libs.stderr)
    exit()

options += root_cflags.stdout.split()
options = [ele for ele in options if not ele.startswith('-std=c++')] # we specify -std=c++ version later
options += root_libs.stdout.split()

# directory of local includes
options += ['-I' + str(header_dir)]

# custom options
options += [
    '-std=c++2a', # to use C++20 under GCC 9
    '-fPIC', # position independent code
    '-O2', # optimization level
]
options = ' '.join(options)

# include local object files
o_files = str(pathlib.Path(src_dir, '*.o'))

# compile
if args.no_linker:
    cmd = f'g++ {options} -c {str(main_path)}'
elif args.standalone:
    cmd = f'g++ {options} -o {str(exec_path)} {str(main_path)}'
else:
    cmd = f'g++ {options} -o {str(exec_path)} {str(main_path)} {o_files}'
compilation = subprocess.run(cmd)
if args.verbose:
    print(compilation.args)
if compilation.stderr:
    sys.stderr.write(compilation.stderr)
if compilation.stdout:
    sys.stdout.write(compilation.stdout)
